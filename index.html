<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ë§ˆë¸” ë£°ë › v2 - ë³µì¡í•œ ë§µ</title>
    <link href="https://fonts.googleapis.com/css2?family=Black+Han+Sans&family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-dark: #0a0a0f;
            --bg-gradient: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #16213e 100%);
            --accent-gold: #ffd700;
            --accent-pink: #ff6b9d;
            --accent-cyan: #00d4ff;
            --accent-purple: #a855f7;
            --accent-green: #10ac84;
            --accent-orange: #ff9f43;
            --glass: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Noto Sans KR', sans-serif;
            background: var(--bg-gradient);
            min-height: 100vh;
            color: #fff;
            overflow-x: hidden;
        }

        .bg-effects {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
            overflow: hidden;
        }

        .bg-effects::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: 
                radial-gradient(circle at 20% 80%, rgba(168, 85, 247, 0.15) 0%, transparent 40%),
                radial-gradient(circle at 80% 20%, rgba(0, 212, 255, 0.15) 0%, transparent 40%),
                radial-gradient(circle at 50% 50%, rgba(255, 107, 157, 0.1) 0%, transparent 50%);
            animation: bgFloat 20s ease-in-out infinite;
        }

        @keyframes bgFloat {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            33% { transform: translate(2%, 2%) rotate(1deg); }
            66% { transform: translate(-2%, 1%) rotate(-1deg); }
        }

        .container {
            position: relative;
            z-index: 1;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 30px;
            min-height: 100vh;
        }

        .sidebar {
            background: var(--glass);
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 24px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            max-height: 95vh;
            overflow-y: auto;
        }

        .sidebar-top {
            display: flex;
            flex-direction: column;
            gap: 16px;
            flex-shrink: 0;
        }

        .sidebar-bottom {
            flex: 1;
            min-height: 200px;
            margin-top: 16px;
            display: flex;
            flex-direction: column;
        }

        .logo-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .logo {
            font-family: 'Black Han Sans', sans-serif;
            font-size: 1.5rem;
            background: linear-gradient(135deg, var(--accent-gold), var(--accent-pink), var(--accent-cyan));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .help-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 2px solid var(--glass-border);
            background: transparent;
            color: #888;
            font-size: 1rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .help-btn:hover {
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
            background: rgba(0, 212, 255, 0.1);
        }

        .section-title {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: #888;
            margin-bottom: 6px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .input-group.compact {
            gap: 4px;
        }

        textarea {
            width: 100%;
            height: 100px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--glass-border);
            border-radius: 10px;
            padding: 12px;
            color: #fff;
            font-family: inherit;
            font-size: 0.85rem;
            resize: none;
            transition: all 0.3s ease;
        }

        textarea:focus {
            outline: none;
            border-color: var(--accent-cyan);
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.2);
        }

        textarea::placeholder { color: #555; }

        .hint {
            font-size: 0.65rem;
            color: #666;
            line-height: 1.3;
        }

        /* Dropdown Select */
        .map-select {
            width: 100%;
            padding: 10px 14px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--glass-border);
            border-radius: 10px;
            color: #fff;
            font-family: inherit;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23888' d='M6 8L1 3h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
        }

        .map-select:focus {
            outline: none;
            border-color: var(--accent-cyan);
        }

        .map-select option {
            background: #1a1a2e;
            color: #fff;
            padding: 10px;
        }

        .btn {
            padding: 12px 16px;
            border: none;
            border-radius: 10px;
            font-family: inherit;
            font-size: 0.9rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .btn-sm {
            padding: 10px 12px;
            font-size: 0.8rem;
        }

        .btn-group {
            display: flex;
            gap: 8px;
        }

        .btn-group .btn-primary {
            flex: 1;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--accent-gold), #ff8c00);
            color: #000;
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.3);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 215, 0, 0.4);
        }

        .btn-secondary {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            color: #fff;
        }

        .btn-secondary:hover { background: rgba(255, 255, 255, 0.1); }

        .btn-reset {
            background: transparent;
            border: 1px solid rgba(255, 107, 157, 0.5);
            color: var(--accent-pink);
        }

        .btn-reset:hover { background: rgba(255, 107, 157, 0.1); }

        .participants-preview {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            max-height: 50px;
            overflow-y: auto;
            padding: 8px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
        }

        .participant-tag {
            display: inline-flex;
            align-items: center;
            gap: 3px;
            padding: 3px 8px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            font-size: 0.7rem;
        }

        .participant-color {
            width: 6px;
            height: 6px;
            border-radius: 50%;
        }

        /* Rankings in Sidebar */
        .rankings {
            flex: 1;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 12px;
            display: flex;
            flex-direction: column;
            min-height: 150px;
            overflow: hidden;
        }

        .rankings-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
            flex-shrink: 0;
        }

        .rankings-header .section-title {
            margin: 0;
        }

        .rankings-live {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.65rem;
            color: var(--accent-pink);
            font-weight: 600;
        }

        .live-dot {
            width: 6px;
            height: 6px;
            background: var(--accent-pink);
            border-radius: 50%;
            animation: livePulse 1s ease-in-out infinite;
        }

        @keyframes livePulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(0.8); }
        }

        #rankingList {
            flex: 1;
            overflow-y: auto;
        }

        .ranking-placeholder {
            text-align: center;
            color: #555;
            font-size: 0.75rem;
            padding: 20px 10px;
        }

        .ranking-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 8px;
            border-radius: 8px;
            margin-bottom: 4px;
            background: rgba(255, 255, 255, 0.02);
            font-size: 0.8rem;
        }

        .ranking-item.rank-1 {
            background: linear-gradient(90deg, rgba(255, 215, 0, 0.2), transparent);
            border: 1px solid rgba(255, 215, 0, 0.3);
        }

        .ranking-item.rank-2 {
            background: linear-gradient(90deg, rgba(192, 192, 192, 0.15), transparent);
            border: 1px solid rgba(192, 192, 192, 0.2);
        }

        .ranking-item.rank-3 {
            background: linear-gradient(90deg, rgba(205, 127, 50, 0.15), transparent);
            border: 1px solid rgba(205, 127, 50, 0.2);
        }

        .ranking-position {
            width: 22px;
            height: 22px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            font-weight: 700;
            font-size: 0.7rem;
            flex-shrink: 0;
        }

        .rank-1 .ranking-position {
            background: linear-gradient(135deg, #ffd700, #ffaa00);
            color: #000;
        }

        .rank-2 .ranking-position {
            background: linear-gradient(135deg, #e0e0e0, #a0a0a0);
            color: #000;
        }

        .rank-3 .ranking-position {
            background: linear-gradient(135deg, #cd7f32, #8b4513);
            color: #fff;
        }

        .ranking-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .ranking-name {
            flex: 1;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .ranking-medal {
            font-size: 0.9rem;
        }

        .ranking-time {
            font-size: 0.65rem;
            color: #666;
            font-family: monospace;
        }

        .ranking-remaining {
            text-align: center;
            color: #666;
            font-size: 0.7rem;
            padding: 6px;
            margin-top: 4px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }

        /* Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal-content {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 20px;
            border-bottom: 1px solid var(--glass-border);
        }

        .modal-header h2 {
            font-size: 1.2rem;
            margin: 0;
        }

        .modal-close {
            width: 32px;
            height: 32px;
            border: none;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            font-size: 1.5rem;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
        }

        .modal-close:hover {
            background: rgba(255, 107, 157, 0.3);
        }

        .modal-body {
            padding: 20px;
        }

        .modal-body h3 {
            font-size: 0.95rem;
            color: var(--accent-cyan);
            margin: 16px 0 8px 0;
        }

        .modal-body h3:first-child {
            margin-top: 0;
        }

        .modal-body p {
            font-size: 0.85rem;
            color: #aaa;
            line-height: 1.6;
            margin: 0;
        }

        .help-legend {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 8px;
        }

        .help-item {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.85rem;
            color: #aaa;
        }

        .help-icon {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .game-area {
            display: flex;
            flex-direction: column;
        }

        .canvas-wrapper {
            position: relative;
            background: var(--glass);
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 24px;
            overflow: hidden;
            flex: 1;
            min-height: 600px;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Winner Overlay */
        .winner-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.92);
            backdrop-filter: blur(10px);
            display: none;
            align-items: center;
            justify-content: flex-start;
            flex-direction: column;
            padding: 30px;
            gap: 15px;
            z-index: 1000;
            overflow-y: auto;
        }

        .winner-overlay.show {
            display: flex;
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .result-header {
            text-align: center;
            margin-bottom: 10px;
        }

        .winner-label {
            font-size: 1rem;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 4px;
            margin-bottom: 8px;
        }

        .winner-name {
            font-family: 'Black Han Sans', sans-serif;
            font-size: 2.8rem;
            background: linear-gradient(135deg, var(--accent-gold), var(--accent-pink), var(--accent-cyan));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-align: center;
            animation: winnerPulse 2s ease-in-out infinite;
        }

        @keyframes winnerPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.03); }
        }

        .final-rankings {
            width: 100%;
            max-width: 450px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 16px;
            max-height: 400px;
            overflow-y: auto;
        }

        .final-rankings-title {
            font-size: 0.85rem;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 12px;
            text-align: center;
        }

        .final-ranking-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 14px;
            border-radius: 10px;
            margin-bottom: 6px;
            background: rgba(255, 255, 255, 0.02);
            animation: resultSlideIn 0.4s ease forwards;
            opacity: 0;
        }

        @keyframes resultSlideIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .final-ranking-item.rank-1 {
            background: linear-gradient(90deg, rgba(255, 215, 0, 0.25), transparent);
            border: 1px solid rgba(255, 215, 0, 0.4);
        }

        .final-ranking-item.rank-2 {
            background: linear-gradient(90deg, rgba(192, 192, 192, 0.2), transparent);
            border: 1px solid rgba(192, 192, 192, 0.3);
        }

        .final-ranking-item.rank-3 {
            background: linear-gradient(90deg, rgba(205, 127, 50, 0.2), transparent);
            border: 1px solid rgba(205, 127, 50, 0.3);
        }

        .final-ranking-item.rank-last {
            background: linear-gradient(90deg, rgba(255, 107, 157, 0.2), transparent);
            border: 1px solid rgba(255, 107, 157, 0.3);
        }

        .final-position {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            font-weight: 700;
            font-size: 0.9rem;
            flex-shrink: 0;
        }

        .rank-1 .final-position {
            background: linear-gradient(135deg, #ffd700, #ffaa00);
            color: #000;
            box-shadow: 0 2px 12px rgba(255, 215, 0, 0.5);
        }

        .rank-2 .final-position {
            background: linear-gradient(135deg, #e0e0e0, #a0a0a0);
            color: #000;
        }

        .rank-3 .final-position {
            background: linear-gradient(135deg, #cd7f32, #8b4513);
            color: #fff;
        }

        .rank-last .final-position {
            background: linear-gradient(135deg, #ff6b9d, #ff4777);
            color: #fff;
        }

        .final-color {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            flex-shrink: 0;
        }

        .final-name {
            flex: 1;
            font-weight: 600;
            font-size: 1rem;
        }

        .final-time {
            font-size: 0.8rem;
            color: #888;
            font-family: monospace;
        }

        .final-medal {
            font-size: 1.2rem;
        }

        .confetti-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
        }

        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            animation: confettiFall 3s ease-in-out forwards;
        }

        @keyframes confettiFall {
            0% { transform: translateY(-100%) rotate(0deg); opacity: 1; }
            100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
        }

        @media (max-width: 900px) {
            .container { grid-template-columns: 1fr; }
            .sidebar { order: 2; max-height: none; }
            .game-area { order: 1; }
            .canvas-wrapper { min-height: 450px; }
            .winner-name { font-size: 2.5rem; }
        }

        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: rgba(255, 255, 255, 0.05); border-radius: 3px; }
        ::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.2); border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: rgba(255, 255, 255, 0.3); }

        .coffee-banner {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-top: 12px;
            padding: 10px 16px;
            background: linear-gradient(135deg, #ffdd00 0%, #ffaa00 100%);
            border-radius: 12px;
            text-decoration: none;
            color: #1a1a1a;
            font-weight: 600;
            font-size: 0.85rem;
            transition: all 0.3s ease;
            flex-shrink: 0;
        }

        .coffee-banner:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(255, 221, 0, 0.4);
        }

        .coffee-icon {
            font-size: 1.1rem;
        }

        .coffee-text {
            letter-spacing: 0.5px;
        }
    </style>
</head>
<body>
    <div class="bg-effects"></div>

    <div class="container">
        <aside class="sidebar">
            <div class="sidebar-top">
                <div class="logo-row">
                    <div class="logo">
                        ğŸ… êµ¬ìŠ¬ ì˜¬ë¦¼í”½
                    </div>
                    <button class="help-btn" id="helpBtn" title="ë„ì›€ë§">?</button>
                </div>

                <div class="input-group">
                    <div class="section-title">ì°¸ì—¬ì ì…ë ¥</div>
                    <textarea id="participants" placeholder="ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš” (ì¤„ë°”ê¿ˆ ë˜ëŠ” ì‰¼í‘œ)
ì˜ˆ: ì² ìˆ˜, ì˜í¬*3, ë¯¼ìˆ˜"></textarea>
                    <div class="hint">ğŸ’¡ ì´ë¦„*ìˆ«ì í˜•ì‹ìœ¼ë¡œ ë³µìˆ˜ ì°¸ì—¬ ê°€ëŠ¥</div>
                </div>

                <div class="input-group">
                    <div class="section-title">ë§µ ì„ íƒ</div>
                    <select id="mapSelect" class="map-select">
                        <option value="chaos">ğŸŒ€ ì¹´ì˜¤ìŠ¤</option>
                        <option value="pinball">ğŸ° í•€ë³¼</option>
                        <option value="funnel">ğŸ”» ê¹”ë•Œê¸°</option>
                    </select>
                </div>

                <div class="input-group compact">
                    <div class="section-title">ì°¸ì—¬ì ë¯¸ë¦¬ë³´ê¸°</div>
                    <div class="participants-preview" id="participantsPreview">
                        <span style="color: #666;">ì°¸ì—¬ìë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”</span>
                    </div>
                </div>

                <div class="btn-group">
                    <button class="btn btn-secondary btn-sm" id="shuffleBtn">ğŸ”€ ì„ê¸°</button>
                    <button class="btn btn-primary" id="startBtn">â–¶ï¸ ì‹œì‘!</button>
                    <button class="btn btn-reset btn-sm" id="resetBtn">â†º ì´ˆê¸°í™”</button>
                </div>
            </div>

            <div class="sidebar-bottom">
                <div class="rankings" id="rankings">
                    <div class="rankings-header">
                        <div class="section-title">ğŸ“Š ì‹¤ì‹œê°„ ìˆœìœ„</div>
                        <div class="rankings-live" id="liveIndicator" style="display: none;">
                            <div class="live-dot"></div>
                            LIVE
                        </div>
                    </div>
                    <div id="rankingList">
                        <div class="ranking-placeholder">ê²Œì„ì„ ì‹œì‘í•˜ë©´ ìˆœìœ„ê°€ í‘œì‹œë©ë‹ˆë‹¤</div>
                    </div>
                </div>
                
                <a href="https://buymeacoffee.com/euiyun" target="_blank" class="coffee-banner">
                    <span class="coffee-icon">â˜•</span>
                    <span class="coffee-text">Buy me a coffee</span>
                </a>
            </div>
        </aside>

        <main class="game-area">
            <div class="canvas-wrapper">
                <canvas id="gameCanvas"></canvas>
            </div>
        </main>
    </div>

    <!-- Help Modal -->
    <div class="modal-overlay" id="helpModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>ğŸ… êµ¬ìŠ¬ ì˜¬ë¦¼í”½ ë„ì›€ë§</h2>
                <button class="modal-close" id="closeHelpBtn">&times;</button>
            </div>
            <div class="modal-body">
                <h3>ğŸ® ê²Œì„ ë°©ë²•</h3>
                <p>ì°¸ì—¬ì ì´ë¦„ì„ ì…ë ¥í•˜ê³  ì‹œì‘ ë²„íŠ¼ì„ ëˆ„ë¥´ë©´ êµ¬ìŠ¬ë“¤ì´ ë–¨ì–´ì§€ë©° ìˆœìœ„ê°€ ê²°ì •ë©ë‹ˆë‹¤.</p>
                
                <h3>ğŸ“ ì°¸ì—¬ì ì…ë ¥</h3>
                <p>â€¢ ì¤„ë°”ê¿ˆ ë˜ëŠ” ì‰¼í‘œë¡œ êµ¬ë¶„<br>â€¢ <strong>ì´ë¦„*ìˆ«ì</strong> í˜•ì‹ìœ¼ë¡œ ë³µìˆ˜ ì°¸ì—¬ (ì˜ˆ: ì² ìˆ˜*3)</p>
                
                <h3>ğŸ—ºï¸ ë§µ ìš”ì†Œ</h3>
                <div class="help-legend">
                    <div class="help-item"><span class="help-icon" style="background: rgba(255,255,255,0.5);"></span> <strong>í•€</strong> - êµ¬ìŠ¬ì´ íŠ•ê¸°ëŠ” ê¸°ë³¸ ì¥ì• ë¬¼</div>
                    <div class="help-item"><span class="help-icon" style="background: #ff6b6b;"></span> <strong>ë²”í¼</strong> - ê°•í•˜ê²Œ íŠ•ê²¨ë‚´ëŠ” ì¥ì• ë¬¼</div>
                    <div class="help-item"><span class="help-icon" style="background: #ffd700;"></span> <strong>íšŒì „ì²´</strong> - ê³„ì† íšŒì „í•˜ëŠ” ë§‰ëŒ€</div>
                    <div class="help-item"><span class="help-icon" style="background: #00d4ff;"></span> <strong>í¬íƒˆ</strong> - ìˆœê°„ì´ë™ ì¥ì¹˜</div>
                    <div class="help-item"><span class="help-icon" style="background: #10ac84;"></span> <strong>ë¶€ìŠ¤í„°</strong> - íŠ¹ì • ë°©í–¥ìœ¼ë¡œ ê°€ì†</div>
                </div>
                
                <h3>ğŸ—ºï¸ ë§µ ì¢…ë¥˜</h3>
                <p>â€¢ <strong>ì¹´ì˜¤ìŠ¤</strong> - ë‹¤ì–‘í•œ ì¥ì• ë¬¼ì´ ë¹½ë¹½í•˜ê²Œ ë°°ì¹˜<br>
                â€¢ <strong>í•€ë³¼</strong> - í•€ë³¼ ë¨¸ì‹  ìŠ¤íƒ€ì¼<br>
                â€¢ <strong>ê¹”ë•Œê¸°</strong> - ì—¬ëŸ¬ ë‹¨ê³„ì˜ ê¹”ë•Œê¸° êµ¬ì¡°</p>
            </div>
        </div>
    </div>

    <div class="winner-overlay" id="winnerOverlay">
        <div class="confetti-container" id="confettiContainer"></div>
        <div class="result-header">
            <div class="winner-label" id="winnerLabel">ğŸ† 1ë“±!</div>
            <div class="winner-name" id="winnerName">-</div>
        </div>
        <div class="final-rankings">
            <div class="final-rankings-title">ğŸ ìµœì¢… ìˆœìœ„</div>
            <div id="finalRankingList"></div>
        </div>
        <button class="btn btn-primary" id="closeWinnerBtn">í™•ì¸</button>
    </div>

    <script>
        // ===== Vector2 =====
        class Vector2 {
            constructor(x = 0, y = 0) { this.x = x; this.y = y; }
            add(v) { return new Vector2(this.x + v.x, this.y + v.y); }
            sub(v) { return new Vector2(this.x - v.x, this.y - v.y); }
            mul(s) { return new Vector2(this.x * s, this.y * s); }
            length() { return Math.sqrt(this.x * this.x + this.y * this.y); }
            normalize() {
                const len = this.length();
                return len > 0 ? this.mul(1 / len) : new Vector2();
            }
            dot(v) { return this.x * v.x + this.y * v.y; }
            rotate(angle) {
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                return new Vector2(this.x * cos - this.y * sin, this.x * sin + this.y * cos);
            }
        }

        // ===== Ball =====
        class Ball {
            constructor(x, y, radius, color, name) {
                this.pos = new Vector2(x, y);
                this.vel = new Vector2(0, 0);
                this.radius = radius;
                this.color = color;
                this.name = name;
                this.restitution = 0.75;
                this.airResistance = 0.9995;
                this.finished = false;
                this.finishTime = null;
                this.trail = [];
                this.maxTrail = 12;
                this.stuckTime = 0;  // ë©ˆì¶°ìˆëŠ” ì‹œê°„ ì¶”ì 
                this.lastPos = new Vector2(x, y);
                this.posHistory = [];  // í•‘í ê°ì§€ìš© ìœ„ì¹˜ íˆìŠ¤í† ë¦¬
                this.posHistoryTimer = 0;
            }

            update(gravity, dt) {
                if (this.finished) {
                    this.trail = [];  // ë„ì°©í•˜ë©´ trail ì œê±°
                    return;
                }
                
                // Trail
                this.trail.push({ x: this.pos.x, y: this.pos.y });
                if (this.trail.length > this.maxTrail) this.trail.shift();
                
                // ê°€ì†ë„ ê¸°ë°˜ ë¬¼ë¦¬
                this.vel = this.vel.add(gravity.mul(dt));
                this.vel = this.vel.mul(this.airResistance);
                this.pos = this.pos.add(this.vel.mul(dt));
                
                // ìœ„ì¹˜ íˆìŠ¤í† ë¦¬ ì—…ë°ì´íŠ¸ (í•‘í ê°ì§€ìš©)
                this.posHistoryTimer += dt;
                if (this.posHistoryTimer >= 0.5) {  // 0.5ì´ˆë§ˆë‹¤ ìœ„ì¹˜ ê¸°ë¡
                    this.posHistoryTimer = 0;
                    this.posHistory.push({ x: this.pos.x, y: this.pos.y });
                    if (this.posHistory.length > 6) this.posHistory.shift();  // ìµœê·¼ 3ì´ˆê°„ ê¸°ë¡
                }
                
                // ë©ˆì¶¤ ê°ì§€ (ì†ë„ê°€ ë§¤ìš° ë‚®ì„ ë•Œ)
                const speed = this.vel.length();
                const moved = this.pos.sub(this.lastPos).length();
                if (speed < 5 && moved < 1) {
                    this.stuckTime += dt;
                } else {
                    this.stuckTime = 0;
                }
                this.lastPos = new Vector2(this.pos.x, this.pos.y);
            }
            
            // í•‘í ìƒíƒœ ê°ì§€ (ì¢ì€ ì˜ì—­ì—ì„œ ì™”ë‹¤ê°”ë‹¤)
            isPingPonging() {
                if (this.posHistory.length < 6) return false;
                
                // ìµœê·¼ 3ì´ˆê°„ì˜ ìœ„ì¹˜ë“¤ì´ ì¢ì€ ë²”ìœ„ ë‚´ì— ìˆëŠ”ì§€ í™•ì¸
                let minX = Infinity, maxX = -Infinity;
                let minY = Infinity, maxY = -Infinity;
                
                for (const p of this.posHistory) {
                    minX = Math.min(minX, p.x);
                    maxX = Math.max(maxX, p.x);
                    minY = Math.min(minY, p.y);
                    maxY = Math.max(maxY, p.y);
                }
                
                const rangeX = maxX - minX;
                const rangeY = maxY - minY;
                
                // X ë²”ìœ„ê°€ ì¢ê³ (100px ì´ë‚´) Yë°©í–¥ ì§„í–‰ì´ ê±°ì˜ ì—†ìœ¼ë©´(50px ì´ë‚´) í•‘í
                return rangeX < 100 && rangeY < 50;
            }
            
            // ë§‰í˜”ì„ ë•Œ ëœë¤ í˜ ì ìš©
            unstuck() {
                const angle = Math.random() * Math.PI * 2;
                const force = 150 + Math.random() * 100;
                this.vel.x += Math.cos(angle) * force;
                this.vel.y += Math.sin(angle) * force - 50;  // ì•½ê°„ ìœ„ë¡œ
                this.stuckTime = 0;
                this.posHistory = [];  // íˆìŠ¤í† ë¦¬ ì´ˆê¸°í™”
            }
            
            // í•‘í íƒˆì¶œ - ë” ê°•í•˜ê²Œ ì•„ë˜ë¡œ
            escapePingPong() {
                const angle = -Math.PI/2 + (Math.random() - 0.5) * Math.PI * 0.5;  // ëŒ€ëµ ì•„ë˜ ë°©í–¥
                const force = 300 + Math.random() * 150;
                this.vel.x = Math.cos(angle) * force;
                this.vel.y = Math.sin(angle) * force + 200;  // ê°•í•˜ê²Œ ì•„ë˜ë¡œ
                this.posHistory = [];
            }
        }

        // ===== Obstacles =====
        class Peg {
            constructor(x, y, radius = 8) {
                this.type = 'peg';
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.color = 'rgba(255, 255, 255, 0.5)';
            }
        }

        class Bumper {
            constructor(x, y, radius = 25) {
                this.type = 'bumper';
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.force = 600;  // ë” ê°•í•œ ë°˜ë°œë ¥
                this.color = '#ff6b6b';
                this.hitTime = 0;
            }
        }

        class Spinner {
            constructor(x, y, length = 60, speed = 2) {
                this.type = 'spinner';
                this.x = x;
                this.y = y;
                this.length = length;
                this.speed = speed;
                this.angle = Math.random() * Math.PI * 2;
                this.color = '#ffd700';
            }

            update(dt) {
                this.angle += this.speed * dt;
            }

            getEndpoints() {
                const dx = Math.cos(this.angle) * this.length / 2;
                const dy = Math.sin(this.angle) * this.length / 2;
                return {
                    x1: this.x - dx, y1: this.y - dy,
                    x2: this.x + dx, y2: this.y + dy
                };
            }
        }

        class Portal {
            constructor(x1, y1, x2, y2, color = '#00d4ff') {
                this.type = 'portal';
                this.x1 = x1; this.y1 = y1;
                this.x2 = x2; this.y2 = y2;
                this.radius = 22;
                this.color = color;
                this.cooldown = new Map();
            }
        }
        
        // í¬íƒˆ ìƒ‰ìƒ íŒ”ë ˆíŠ¸
        const PORTAL_COLORS = [
            '#00d4ff',  // ì‹œì•ˆ
            '#ff6b9d',  // í•‘í¬
            '#a855f7',  // ë³´ë¼
            '#10ac84',  // ì´ˆë¡
        ];

        class Booster {
            constructor(x, y, angle, force = 600) {
                this.type = 'booster';
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.force = force;
                this.radius = 18;
                this.color = '#10ac84';
                this.hitTime = 0;
            }
        }

        class Wall {
            constructor(x1, y1, x2, y2, thickness = 6) {
                this.type = 'wall';
                this.x1 = x1; this.y1 = y1;
                this.x2 = x2; this.y2 = y2;
                this.thickness = thickness;
                this.color = 'rgba(255, 255, 255, 0.3)';
            }
        }

        class Triangle {
            constructor(x, y, size, angle = 0) {
                this.type = 'triangle';
                this.x = x;
                this.y = y;
                this.size = size;
                this.angle = angle;
                this.color = 'rgba(255, 159, 67, 0.6)';
            }

            getVertices() {
                const verts = [];
                for (let i = 0; i < 3; i++) {
                    const a = this.angle + (i * Math.PI * 2 / 3) - Math.PI / 2;
                    verts.push({
                        x: this.x + Math.cos(a) * this.size,
                        y: this.y + Math.sin(a) * this.size
                    });
                }
                return verts;
            }
        }

        // ===== Physics World =====
        class PhysicsWorld {
            constructor(width, viewHeight) {
                this.width = width;
                this.viewHeight = viewHeight;  // ë³´ì´ëŠ” í™”ë©´ ë†’ì´
                this.height = viewHeight * 3;  // ì‹¤ì œ ë§µ ë†’ì´ (3ë°°)
                // ì¤‘ë ¥ì„ ë‚®ì¶°ì„œ í•€ë³¼ì²˜ëŸ¼ ì²œì²œíˆ ê°€ì†
                this.gravity = new Vector2(0, 320);
                this.balls = [];
                this.obstacles = [];
                this.finishLine = this.height - 70;
                this.rankings = [];
                this.time = 0;
                this.cameraY = 0;  // ì¹´ë©”ë¼ Y ìœ„ì¹˜
            }

            addBall(ball) { this.balls.push(ball); }
            addObstacle(obs) { this.obstacles.push(obs); }
            
            // ê°€ì¥ ì•ì„œê°€ëŠ” ê³µ(ì•„ì§ ë„ì°© ì•ˆ í•œ ê³µ ì¤‘ ê°€ì¥ ì•„ë˜ì— ìˆëŠ” ê³µ) ì°¾ê¸°
            getLeadingBall() {
                let leader = null;
                let maxY = -Infinity;
                for (const ball of this.balls) {
                    if (!ball.finished && ball.pos.y > maxY) {
                        maxY = ball.pos.y;
                        leader = ball;
                    }
                }
                return leader;
            }
            
            updateCamera() {
                const leader = this.getLeadingBall();
                if (leader) {
                    // ë¦¬ë”ê°€ í™”ë©´ì˜ ìƒë‹¨ 1/3 ì§€ì ì— ì˜¤ë„ë¡ ì¹´ë©”ë¼ ì´ë™
                    const targetY = leader.pos.y - this.viewHeight * 0.35;
                    // ë¶€ë“œëŸ¬ìš´ ì¹´ë©”ë¼ ì´ë™
                    this.cameraY += (targetY - this.cameraY) * 0.08;
                    // ë²”ìœ„ ì œí•œ
                    this.cameraY = Math.max(0, Math.min(this.cameraY, this.height - this.viewHeight));
                }
            }

            update(dt) {
                this.time += dt;

                // Update spinners
                for (const obs of this.obstacles) {
                    if (obs.type === 'spinner') obs.update(dt);
                }

                for (const ball of this.balls) {
                    ball.update(this.gravity, dt);
                    this.collideWalls(ball);

                    for (const obs of this.obstacles) {
                        this.collideObstacle(ball, obs);
                    }

                    // Finish line
                    if (!ball.finished && ball.pos.y + ball.radius >= this.finishLine) {
                        ball.finished = true;
                        ball.finishTime = performance.now();
                        ball.pos.y = this.finishLine - ball.radius;
                        ball.vel = new Vector2(ball.vel.x * 0.2, 0);
                        ball.trail = [];  // trail ì¦‰ì‹œ ì œê±°
                        this.rankings.push(ball);
                    }
                    
                    // ë§‰í˜ ê°ì§€ ë° í•´ì œ (1.5ì´ˆ ì´ìƒ ë©ˆì¶°ìˆìœ¼ë©´)
                    if (!ball.finished && ball.stuckTime > 1.5) {
                        ball.unstuck();
                    }
                    
                    // í•‘í ê°ì§€ ë° íƒˆì¶œ (ì¢ì€ ë²”ìœ„ì—ì„œ ì™”ë‹¤ê°”ë‹¤ í•  ë•Œ)
                    if (!ball.finished && ball.isPingPonging()) {
                        ball.escapePingPong();
                    }
                }

                // Ball-ball collision
                for (let i = 0; i < this.balls.length; i++) {
                    for (let j = i + 1; j < this.balls.length; j++) {
                        this.collideBalls(this.balls[i], this.balls[j]);
                    }
                }
                
                // ì¹´ë©”ë¼ ì—…ë°ì´íŠ¸
                this.updateCamera();
            }

            collideWalls(ball) {
                const margin = 5;
                // ë²½ ì¶©ëŒ ì‹œ ì—ë„ˆì§€ ë³´ì¡´ìœ¨ ë†’ì„
                const wallRestitution = 0.85;
                
                if (ball.pos.x - ball.radius < margin) {
                    ball.pos.x = ball.radius + margin;
                    ball.vel.x *= -wallRestitution;
                }
                if (ball.pos.x + ball.radius > this.width - margin) {
                    ball.pos.x = this.width - ball.radius - margin;
                    ball.vel.x *= -wallRestitution;
                }
                if (ball.pos.y - ball.radius < margin) {
                    ball.pos.y = ball.radius + margin;
                    ball.vel.y *= -wallRestitution;
                }
            }

            collideObstacle(ball, obs) {
                if (obs.type === 'peg') {
                    this.collideCircle(ball, obs.x, obs.y, obs.radius, ball.restitution);
                } else if (obs.type === 'bumper') {
                    if (this.collideCircle(ball, obs.x, obs.y, obs.radius, 1.0)) {
                        // ë²”í¼ì—ì„œ ê°•í•˜ê²Œ íŠ•ê²¨ë‚˜ê°
                        const dx = ball.pos.x - obs.x;
                        const dy = ball.pos.y - obs.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist > 0) {
                            const impulse = obs.force;
                            ball.vel.x += (dx / dist) * impulse * 0.05;
                            ball.vel.y += (dy / dist) * impulse * 0.05;
                        }
                        obs.hitTime = this.time;
                    }
                } else if (obs.type === 'spinner') {
                    const ep = obs.getEndpoints();
                    this.collideLine(ball, ep.x1, ep.y1, ep.x2, ep.y2, 5);
                } else if (obs.type === 'wall') {
                    this.collideLine(ball, obs.x1, obs.y1, obs.x2, obs.y2, obs.thickness);
                } else if (obs.type === 'portal') {
                    const dist1 = Math.sqrt((ball.pos.x - obs.x1) ** 2 + (ball.pos.y - obs.y1) ** 2);
                    const dist2 = Math.sqrt((ball.pos.x - obs.x2) ** 2 + (ball.pos.y - obs.y2) ** 2);
                    
                    const lastTeleport = obs.cooldown.get(ball) || 0;
                    if (this.time - lastTeleport > 0.5) {
                        if (dist1 < obs.radius + ball.radius) {
                            ball.pos.x = obs.x2;
                            ball.pos.y = obs.y2 + obs.radius + ball.radius + 5;
                            obs.cooldown.set(ball, this.time);
                        } else if (dist2 < obs.radius + ball.radius) {
                            ball.pos.x = obs.x1;
                            ball.pos.y = obs.y1 + obs.radius + ball.radius + 5;
                            obs.cooldown.set(ball, this.time);
                        }
                    }
                } else if (obs.type === 'booster') {
                    const dist = Math.sqrt((ball.pos.x - obs.x) ** 2 + (ball.pos.y - obs.y) ** 2);
                    if (dist < obs.radius + ball.radius) {
                        // ë¶€ìŠ¤í„° ë°©í–¥ìœ¼ë¡œ ê°•í•˜ê²Œ ê°€ì†
                        ball.vel.x += Math.cos(obs.angle) * obs.force * 0.06;
                        ball.vel.y += Math.sin(obs.angle) * obs.force * 0.06;
                        obs.hitTime = this.time;
                    }
                } else if (obs.type === 'triangle') {
                    const verts = obs.getVertices();
                    for (let i = 0; i < 3; i++) {
                        const v1 = verts[i];
                        const v2 = verts[(i + 1) % 3];
                        this.collideLine(ball, v1.x, v1.y, v2.x, v2.y, 3);
                    }
                }
            }

            collideCircle(ball, cx, cy, cr, restitution) {
                const dx = ball.pos.x - cx;
                const dy = ball.pos.y - cy;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const minDist = ball.radius + cr;

                if (dist < minDist && dist > 0) {
                    const nx = dx / dist;
                    const ny = dy / dist;
                    const overlap = minDist - dist;

                    ball.pos.x += nx * overlap;
                    ball.pos.y += ny * overlap;

                    const dotProduct = ball.vel.x * nx + ball.vel.y * ny;
                    // ë°˜ë°œ ê³„ìˆ˜ ì ìš© (ì—ë„ˆì§€ ë³´ì¡´ìœ¨ ë†’ìŒ)
                    const bounce = 1 + restitution * ball.restitution;
                    ball.vel.x -= bounce * dotProduct * nx;
                    ball.vel.y -= bounce * dotProduct * ny;
                    return true;
                }
                return false;
            }

            collideLine(ball, x1, y1, x2, y2, thickness) {
                const lineVec = new Vector2(x2 - x1, y2 - y1);
                const lineLen = lineVec.length();
                if (lineLen === 0) return;
                
                const lineDir = lineVec.normalize();
                const toBall = new Vector2(ball.pos.x - x1, ball.pos.y - y1);
                
                let t = toBall.dot(lineDir);
                t = Math.max(0, Math.min(lineLen, t));
                
                const closest = new Vector2(x1 + lineDir.x * t, y1 + lineDir.y * t);
                const dist = ball.pos.sub(closest).length();
                const minDist = ball.radius + thickness / 2;
                
                if (dist < minDist && dist > 0) {
                    const normal = ball.pos.sub(closest).normalize();
                    const overlap = minDist - dist;
                    
                    ball.pos = ball.pos.add(normal.mul(overlap));
                    
                    const dotProduct = ball.vel.x * normal.x + ball.vel.y * normal.y;
                    // ì—ë„ˆì§€ ë³´ì¡´ìœ¨ ë†’ì„
                    const bounce = 1 + ball.restitution * 0.9;
                    ball.vel.x -= bounce * dotProduct * normal.x;
                    ball.vel.y -= bounce * dotProduct * normal.y;
                }
            }

            collideBalls(a, b) {
                const dx = b.pos.x - a.pos.x;
                const dy = b.pos.y - a.pos.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const minDist = a.radius + b.radius;

                if (dist < minDist && dist > 0) {
                    const nx = dx / dist;
                    const ny = dy / dist;
                    const overlap = minDist - dist;

                    a.pos.x -= nx * overlap * 0.5;
                    a.pos.y -= ny * overlap * 0.5;
                    b.pos.x += nx * overlap * 0.5;
                    b.pos.y += ny * overlap * 0.5;

                    const relVelX = a.vel.x - b.vel.x;
                    const relVelY = a.vel.y - b.vel.y;
                    const relVelDot = relVelX * nx + relVelY * ny;

                    if (relVelDot > 0) {
                        // íƒ„ì„± ì¶©ëŒì— ê°€ê¹ê²Œ (ì—ë„ˆì§€ ê±°ì˜ ë³´ì¡´)
                        const restitution = 0.95;
                        const impulse = relVelDot * (1 + restitution) / 2;

                        a.vel.x -= impulse * nx;
                        a.vel.y -= impulse * ny;
                        b.vel.x += impulse * nx;
                        b.vel.y += impulse * ny;
                    }
                }
            }

            isFinished() {
                return this.balls.length > 0 && this.balls.every(b => b.finished);
            }
        }

        // ===== Map Generators =====
        // ë§µì€ viewHeightì˜ 3ë°° ë†’ì´ë¡œ ìƒì„±ë¨
        const MapGenerators = {
            chaos(world, w, h) {
                // hëŠ” ì´ì œ ì‹¤ì œ ë§µ ë†’ì´ (viewHeight * 3)
                
                // ===== í¬íƒˆ 4ìŒ (ìƒ‰ìƒë³„) =====
                world.addObstacle(new Portal(w * 0.08, h * 0.08, w * 0.92, h * 0.22, PORTAL_COLORS[0]));  // ì‹œì•ˆ
                world.addObstacle(new Portal(w * 0.15, h * 0.35, w * 0.85, h * 0.52, PORTAL_COLORS[1]));  // í•‘í¬
                world.addObstacle(new Portal(w * 0.1, h * 0.58, w * 0.5, h * 0.72, PORTAL_COLORS[2]));   // ë³´ë¼
                world.addObstacle(new Portal(w * 0.9, h * 0.75, w * 0.2, h * 0.88, PORTAL_COLORS[3]));   // ì´ˆë¡
                
                // ===== ì„¹ì…˜ 1 (0% ~ 15%) - ì‹œì‘ êµ¬ê°„ =====
                // ë°€ì§‘ í•€ í•„ë“œ
                for (let row = 0; row < 10; row++) {
                    const cols = row % 2 === 0 ? 9 : 8;
                    const baseOffsetX = row % 2 === 0 ? w / 18 : w / 18 + w / 18;
                    for (let col = 0; col < cols; col++) {
                        const x = baseOffsetX + col * (w / 9);
                        const y = 60 + row * 42;
                        world.addObstacle(new Peg(x, y, 6));
                    }
                }
                world.addObstacle(new Spinner(w * 0.2, h * 0.06, 55, 3.5));
                world.addObstacle(new Spinner(w * 0.5, h * 0.04, 65, -3));
                world.addObstacle(new Spinner(w * 0.8, h * 0.06, 55, 3.5));
                world.addObstacle(new Bumper(w * 0.35, h * 0.1, 22));
                world.addObstacle(new Bumper(w * 0.65, h * 0.1, 22));

                // ===== ì„¹ì…˜ 2 (15% ~ 30%) - ë²”í¼ ì§€ì˜¥ =====
                world.addObstacle(new Bumper(w * 0.15, h * 0.17, 28));
                world.addObstacle(new Bumper(w * 0.35, h * 0.15, 26));
                world.addObstacle(new Bumper(w * 0.5, h * 0.18, 30));
                world.addObstacle(new Bumper(w * 0.65, h * 0.15, 26));
                world.addObstacle(new Bumper(w * 0.85, h * 0.17, 28));
                world.addObstacle(new Spinner(w * 0.25, h * 0.22, 70, -2.5));
                world.addObstacle(new Spinner(w * 0.75, h * 0.22, 70, 2.5));
                world.addObstacle(new Bumper(w * 0.5, h * 0.25, 32));
                // ì‚¼ê°í˜• ì¥ì• ë¬¼
                world.addObstacle(new Triangle(w * 0.2, h * 0.28, 28, Math.PI / 6));
                world.addObstacle(new Triangle(w * 0.8, h * 0.28, 28, -Math.PI / 6));

                // ===== ì„¹ì…˜ 3 (30% ~ 45%) - ìŠ¤í”¼ë„ˆ ìˆ² =====
                world.addObstacle(new Spinner(w * 0.15, h * 0.32, 50, 3));
                world.addObstacle(new Spinner(w * 0.35, h * 0.35, 60, -2.5));
                world.addObstacle(new Spinner(w * 0.55, h * 0.33, 55, 3));
                world.addObstacle(new Spinner(w * 0.75, h * 0.36, 60, -2.5));
                world.addObstacle(new Spinner(w * 0.9, h * 0.34, 45, 3));
                // í•€ ì‚°ê°œ ë°°ì¹˜
                for (let row = 0; row < 6; row++) {
                    const cols = row % 2 === 0 ? 7 : 6;
                    const baseOffsetX = row % 2 === 0 ? w / 14 : w / 14 + w / 14;
                    for (let col = 0; col < cols; col++) {
                        const x = baseOffsetX + col * (w / 7);
                        const y = h * 0.38 + row * 38;
                        world.addObstacle(new Peg(x, y, 5));
                    }
                }
                world.addObstacle(new Booster(w * 0.1, h * 0.42, -Math.PI / 5, 650));
                world.addObstacle(new Booster(w * 0.9, h * 0.42, -Math.PI * 4 / 5, 650));

                // ===== ì„¹ì…˜ 4 (45% ~ 60%) - ë¶€ìŠ¤í„° ì¡´ =====
                world.addObstacle(new Bumper(w * 0.25, h * 0.48, 26));
                world.addObstacle(new Bumper(w * 0.5, h * 0.46, 30));
                world.addObstacle(new Bumper(w * 0.75, h * 0.48, 26));
                world.addObstacle(new Booster(w * 0.15, h * 0.52, -Math.PI / 3, 700));
                world.addObstacle(new Booster(w * 0.5, h * 0.54, -Math.PI / 2, 800));
                world.addObstacle(new Booster(w * 0.85, h * 0.52, -Math.PI * 2 / 3, 700));
                world.addObstacle(new Spinner(w * 0.35, h * 0.56, 65, 2.5));
                world.addObstacle(new Spinner(w * 0.65, h * 0.56, 65, -2.5));
                // ë²½ ì¥ì• ë¬¼
                world.addObstacle(new Wall(w * 0.2, h * 0.58, w * 0.35, h * 0.62, 6));
                world.addObstacle(new Wall(w * 0.8, h * 0.58, w * 0.65, h * 0.62, 6));

                // ===== ì„¹ì…˜ 5 (60% ~ 75%) - ë°€ì§‘ í•€ + ë²”í¼ =====
                for (let row = 0; row < 8; row++) {
                    const cols = row % 2 === 0 ? 10 : 9;
                    const baseOffsetX = row % 2 === 0 ? w / 20 : w / 20 + w / 20;
                    for (let col = 0; col < cols; col++) {
                        const x = baseOffsetX + col * (w / 10);
                        const y = h * 0.63 + row * 35;
                        world.addObstacle(new Peg(x, y, 5));
                    }
                }
                world.addObstacle(new Bumper(w * 0.2, h * 0.67, 24));
                world.addObstacle(new Bumper(w * 0.4, h * 0.7, 22));
                world.addObstacle(new Bumper(w * 0.6, h * 0.7, 22));
                world.addObstacle(new Bumper(w * 0.8, h * 0.67, 24));
                world.addObstacle(new Spinner(w * 0.5, h * 0.73, 80, 3));

                // ===== ì„¹ì…˜ 6 (75% ~ 90%) - ìµœì¢… êµ¬ê°„ =====
                world.addObstacle(new Triangle(w * 0.25, h * 0.78, 30, Math.PI / 4));
                world.addObstacle(new Triangle(w * 0.75, h * 0.78, 30, -Math.PI / 4));
                world.addObstacle(new Bumper(w * 0.15, h * 0.82, 26));
                world.addObstacle(new Bumper(w * 0.5, h * 0.8, 32));
                world.addObstacle(new Bumper(w * 0.85, h * 0.82, 26));
                world.addObstacle(new Spinner(w * 0.3, h * 0.85, 55, -3));
                world.addObstacle(new Spinner(w * 0.7, h * 0.85, 55, 3));
                world.addObstacle(new Booster(w * 0.2, h * 0.9, -Math.PI / 2, 500));
                world.addObstacle(new Booster(w * 0.5, h * 0.92, -Math.PI / 2, 600));
                world.addObstacle(new Booster(w * 0.8, h * 0.9, -Math.PI / 2, 500));
            },

            pinball(world, w, h) {
                // ===== í¬íƒˆ 4ìŒ (ìƒ‰ìƒë³„) =====
                world.addObstacle(new Portal(w * 0.1, h * 0.05, w * 0.9, h * 0.18, PORTAL_COLORS[0]));   // ì‹œì•ˆ
                world.addObstacle(new Portal(w * 0.08, h * 0.3, w * 0.5, h * 0.45, PORTAL_COLORS[1]));   // í•‘í¬
                world.addObstacle(new Portal(w * 0.92, h * 0.5, w * 0.15, h * 0.68, PORTAL_COLORS[2])); // ë³´ë¼
                world.addObstacle(new Portal(w * 0.3, h * 0.75, w * 0.7, h * 0.88, PORTAL_COLORS[3]));  // ì´ˆë¡

                // ===== ì„¹ì…˜ 1 (0% ~ 15%) - ìƒë‹¨ ë²”í¼ í´ëŸ¬ìŠ¤í„° =====
                world.addObstacle(new Bumper(w * 0.25, h * 0.03, 28));
                world.addObstacle(new Bumper(w * 0.4, h * 0.05, 24));
                world.addObstacle(new Bumper(w * 0.5, h * 0.02, 26));
                world.addObstacle(new Bumper(w * 0.6, h * 0.05, 24));
                world.addObstacle(new Bumper(w * 0.75, h * 0.03, 28));
                world.addObstacle(new Wall(5, h * 0.01, w * 0.12, h * 0.1, 8));
                world.addObstacle(new Wall(w - 5, h * 0.01, w * 0.88, h * 0.1, 8));
                world.addObstacle(new Spinner(w * 0.35, h * 0.08, 50, -3));
                world.addObstacle(new Spinner(w * 0.65, h * 0.08, 50, 3));

                // ===== ì„¹ì…˜ 2 (15% ~ 30%) - í•€ + ìŠ¤í”¼ë„ˆ =====
                for (let row = 0; row < 8; row++) {
                    const cols = row % 2 === 0 ? 8 : 7;
                    const baseOffsetX = row % 2 === 0 ? w / 16 : w / 16 + w / 16;
                    for (let col = 0; col < cols; col++) {
                        const x = baseOffsetX + col * (w / 8);
                        const y = h * 0.12 + row * 38;
                        world.addObstacle(new Peg(x, y, 5));
                    }
                }
                world.addObstacle(new Spinner(w * 0.2, h * 0.18, 60, 2.5));
                world.addObstacle(new Spinner(w * 0.5, h * 0.16, 75, -3));
                world.addObstacle(new Spinner(w * 0.8, h * 0.18, 60, 2.5));
                world.addObstacle(new Bumper(w * 0.35, h * 0.22, 22));
                world.addObstacle(new Bumper(w * 0.65, h * 0.22, 22));

                // ===== ì„¹ì…˜ 3 (30% ~ 45%) - ì‚¬ì´ë“œ ë²½ + ë²”í¼ =====
                world.addObstacle(new Wall(5, h * 0.25, w * 0.15, h * 0.4, 8));
                world.addObstacle(new Wall(w - 5, h * 0.25, w * 0.85, h * 0.4, 8));
                world.addObstacle(new Bumper(w * 0.2, h * 0.28, 30));
                world.addObstacle(new Bumper(w * 0.4, h * 0.32, 26));
                world.addObstacle(new Bumper(w * 0.5, h * 0.28, 32));
                world.addObstacle(new Bumper(w * 0.6, h * 0.32, 26));
                world.addObstacle(new Bumper(w * 0.8, h * 0.28, 30));
                world.addObstacle(new Booster(w * 0.12, h * 0.35, -Math.PI / 4, 750));
                world.addObstacle(new Booster(w * 0.88, h * 0.35, -Math.PI * 3 / 4, 750));
                world.addObstacle(new Spinner(w * 0.5, h * 0.38, 85, 3));
                world.addObstacle(new Triangle(w * 0.3, h * 0.42, 28));
                world.addObstacle(new Triangle(w * 0.7, h * 0.42, 28));

                // ===== ì„¹ì…˜ 4 (45% ~ 60%) - ìŠ¤í”¼ë„ˆ ë¯¸ë¡œ =====
                world.addObstacle(new Spinner(w * 0.15, h * 0.48, 55, -2.5));
                world.addObstacle(new Spinner(w * 0.3, h * 0.52, 60, 3));
                world.addObstacle(new Spinner(w * 0.5, h * 0.48, 70, -2.5));
                world.addObstacle(new Spinner(w * 0.7, h * 0.52, 60, 3));
                world.addObstacle(new Spinner(w * 0.85, h * 0.48, 55, -2.5));
                for (let row = 0; row < 5; row++) {
                    const cols = row % 2 === 0 ? 6 : 5;
                    const baseOffsetX = row % 2 === 0 ? w / 12 : w / 12 + w / 12;
                    for (let col = 0; col < cols; col++) {
                        const x = baseOffsetX + col * (w / 6);
                        const y = h * 0.54 + row * 35;
                        world.addObstacle(new Peg(x, y, 5));
                    }
                }
                world.addObstacle(new Bumper(w * 0.25, h * 0.58, 24));
                world.addObstacle(new Bumper(w * 0.5, h * 0.56, 28));
                world.addObstacle(new Bumper(w * 0.75, h * 0.58, 24));

                // ===== ì„¹ì…˜ 5 (60% ~ 75%) - í•€ë³¼ í”Œë¦¬í¼ ì¡´ =====
                world.addObstacle(new Wall(w * 0.1, h * 0.62, w * 0.25, h * 0.72, 6));
                world.addObstacle(new Wall(w * 0.9, h * 0.62, w * 0.75, h * 0.72, 6));
                world.addObstacle(new Triangle(w * 0.28, h * 0.68, 32, Math.PI / 6));
                world.addObstacle(new Triangle(w * 0.72, h * 0.68, 32, -Math.PI / 6));
                for (let row = 0; row < 6; row++) {
                    const cols = row % 2 === 0 ? 7 : 6;
                    const baseOffsetX = row % 2 === 0 ? w / 14 : w / 14 + w / 14;
                    for (let col = 0; col < cols; col++) {
                        const x = baseOffsetX + col * (w / 7);
                        const y = h * 0.65 + row * 35;
                        world.addObstacle(new Peg(x, y, 5));
                    }
                }
                world.addObstacle(new Bumper(w * 0.4, h * 0.72, 24));
                world.addObstacle(new Bumper(w * 0.6, h * 0.72, 24));
                world.addObstacle(new Spinner(w * 0.5, h * 0.75, 70, -3));

                // ===== ì„¹ì…˜ 6 (75% ~ 90%) - ìµœì¢… êµ¬ê°„ =====
                world.addObstacle(new Bumper(w * 0.2, h * 0.8, 26));
                world.addObstacle(new Bumper(w * 0.35, h * 0.82, 22));
                world.addObstacle(new Bumper(w * 0.5, h * 0.78, 30));
                world.addObstacle(new Bumper(w * 0.65, h * 0.82, 22));
                world.addObstacle(new Bumper(w * 0.8, h * 0.8, 26));
                world.addObstacle(new Spinner(w * 0.25, h * 0.86, 50, 3));
                world.addObstacle(new Spinner(w * 0.75, h * 0.86, 50, -3));
                world.addObstacle(new Booster(w * 0.3, h * 0.9, -Math.PI / 2, 550));
                world.addObstacle(new Booster(w * 0.5, h * 0.92, -Math.PI / 2, 650));
                world.addObstacle(new Booster(w * 0.7, h * 0.9, -Math.PI / 2, 550));
                world.addObstacle(new Triangle(w * 0.15, h * 0.92, 25, Math.PI / 4));
                world.addObstacle(new Triangle(w * 0.85, h * 0.92, 25, -Math.PI / 4));
            },

            funnel(world, w, h) {
                // ===== í¬íƒˆ 4ìŒ (ìƒ‰ìƒë³„) =====
                world.addObstacle(new Portal(w * 0.08, h * 0.06, w * 0.92, h * 0.2, PORTAL_COLORS[0]));  // ì‹œì•ˆ
                world.addObstacle(new Portal(w * 0.12, h * 0.32, w * 0.88, h * 0.48, PORTAL_COLORS[1])); // í•‘í¬
                world.addObstacle(new Portal(w * 0.1, h * 0.55, w * 0.5, h * 0.7, PORTAL_COLORS[2]));   // ë³´ë¼
                world.addObstacle(new Portal(w * 0.9, h * 0.72, w * 0.25, h * 0.88, PORTAL_COLORS[3])); // ì´ˆë¡

                // ===== ë ˆì´ì–´ 1 (0% ~ 12%) - ìƒë‹¨ ê¹”ë•Œê¸° =====
                world.addObstacle(new Wall(5, h * 0.01, w * 0.22, h * 0.08, 6));
                world.addObstacle(new Wall(w - 5, h * 0.01, w * 0.78, h * 0.08, 6));
                world.addObstacle(new Bumper(w * 0.35, h * 0.03, 20));
                world.addObstacle(new Bumper(w * 0.5, h * 0.02, 22));
                world.addObstacle(new Bumper(w * 0.65, h * 0.03, 20));
                world.addObstacle(new Spinner(w * 0.5, h * 0.06, 60, 3));
                // í•€ ë°°ì¹˜
                for (let row = 0; row < 4; row++) {
                    const cols = row % 2 === 0 ? 6 : 5;
                    const baseOffsetX = row % 2 === 0 ? w / 12 : w / 12 + w / 12;
                    for (let col = 0; col < cols; col++) {
                        const x = baseOffsetX + col * (w / 6);
                        const y = h * 0.08 + row * 30;
                        world.addObstacle(new Peg(x, y, 5));
                    }
                }

                // ===== ë ˆì´ì–´ 2 (12% ~ 24%) - ë‘ ë²ˆì§¸ ê¹”ë•Œê¸° =====
                world.addObstacle(new Wall(w * 0.1, h * 0.12, w * 0.32, h * 0.2, 6));
                world.addObstacle(new Wall(w * 0.9, h * 0.12, w * 0.68, h * 0.2, 6));
                world.addObstacle(new Spinner(w * 0.25, h * 0.16, 50, -2.5));
                world.addObstacle(new Spinner(w * 0.75, h * 0.16, 50, 2.5));
                world.addObstacle(new Bumper(w * 0.5, h * 0.18, 26));
                world.addObstacle(new Triangle(w * 0.35, h * 0.22, 22));
                world.addObstacle(new Triangle(w * 0.65, h * 0.22, 22));

                // ===== ë ˆì´ì–´ 3 (24% ~ 36%) - 3ê°ˆë˜ ë¶„ê¸° =====
                world.addObstacle(new Wall(w * 0.15, h * 0.24, w * 0.3, h * 0.34, 6));
                world.addObstacle(new Wall(w * 0.85, h * 0.24, w * 0.7, h * 0.34, 6));
                world.addObstacle(new Wall(w * 0.42, h * 0.26, w * 0.42, h * 0.33, 5));
                world.addObstacle(new Wall(w * 0.58, h * 0.26, w * 0.58, h * 0.33, 5));
                world.addObstacle(new Bumper(w * 0.28, h * 0.3, 18));
                world.addObstacle(new Bumper(w * 0.5, h * 0.28, 20));
                world.addObstacle(new Bumper(w * 0.72, h * 0.3, 18));
                world.addObstacle(new Spinner(w * 0.28, h * 0.35, 40, 3));
                world.addObstacle(new Spinner(w * 0.5, h * 0.36, 45, -2.5));
                world.addObstacle(new Spinner(w * 0.72, h * 0.35, 40, 3));

                // ===== ë ˆì´ì–´ 4 (36% ~ 48%) - ë²”í¼ í•„ë“œ =====
                world.addObstacle(new Bumper(w * 0.15, h * 0.4, 24));
                world.addObstacle(new Bumper(w * 0.3, h * 0.42, 22));
                world.addObstacle(new Bumper(w * 0.45, h * 0.4, 26));
                world.addObstacle(new Bumper(w * 0.55, h * 0.42, 24));
                world.addObstacle(new Bumper(w * 0.7, h * 0.4, 22));
                world.addObstacle(new Bumper(w * 0.85, h * 0.42, 24));
                world.addObstacle(new Booster(w * 0.1, h * 0.46, -Math.PI / 4, 700));
                world.addObstacle(new Booster(w * 0.9, h * 0.46, -Math.PI * 3 / 4, 700));
                // í•€ ì‚°ê°œ
                for (let row = 0; row < 4; row++) {
                    const cols = row % 2 === 0 ? 5 : 4;
                    const baseOffsetX = row % 2 === 0 ? w / 10 : w / 10 + w / 10;
                    for (let col = 0; col < cols; col++) {
                        const x = baseOffsetX + col * (w / 5);
                        const y = h * 0.44 + row * 28;
                        world.addObstacle(new Peg(x, y, 5));
                    }
                }

                // ===== ë ˆì´ì–´ 5 (48% ~ 60%) - ìŠ¤í”¼ë„ˆ ì¡´ =====
                world.addObstacle(new Spinner(w * 0.15, h * 0.52, 55, 3));
                world.addObstacle(new Spinner(w * 0.35, h * 0.55, 60, -2.5));
                world.addObstacle(new Spinner(w * 0.5, h * 0.52, 65, 3));
                world.addObstacle(new Spinner(w * 0.65, h * 0.55, 60, -2.5));
                world.addObstacle(new Spinner(w * 0.85, h * 0.52, 55, 3));
                world.addObstacle(new Wall(5, h * 0.56, w * 0.2, h * 0.62, 6));
                world.addObstacle(new Wall(w - 5, h * 0.56, w * 0.8, h * 0.62, 6));
                world.addObstacle(new Bumper(w * 0.35, h * 0.6, 22));
                world.addObstacle(new Bumper(w * 0.65, h * 0.6, 22));

                // ===== ë ˆì´ì–´ 6 (60% ~ 72%) - í•€ ë°€ì§‘ êµ¬ê°„ =====
                for (let row = 0; row < 8; row++) {
                    const cols = row % 2 === 0 ? 9 : 8;
                    const baseOffsetX = row % 2 === 0 ? w / 18 : w / 18 + w / 18;
                    for (let col = 0; col < cols; col++) {
                        const x = baseOffsetX + col * (w / 9);
                        const y = h * 0.62 + row * 32;
                        world.addObstacle(new Peg(x, y, 5));
                    }
                }
                world.addObstacle(new Spinner(w * 0.25, h * 0.68, 50, -2));
                world.addObstacle(new Spinner(w * 0.5, h * 0.66, 55, 2.5));
                world.addObstacle(new Spinner(w * 0.75, h * 0.68, 50, -2));

                // ===== ë ˆì´ì–´ 7 (72% ~ 84%) - ìµœì¢… ê¹”ë•Œê¸° =====
                world.addObstacle(new Wall(w * 0.08, h * 0.74, w * 0.28, h * 0.82, 6));
                world.addObstacle(new Wall(w * 0.92, h * 0.74, w * 0.72, h * 0.82, 6));
                world.addObstacle(new Triangle(w * 0.32, h * 0.78, 25));
                world.addObstacle(new Triangle(w * 0.68, h * 0.78, 25));
                world.addObstacle(new Bumper(w * 0.5, h * 0.76, 28));
                world.addObstacle(new Spinner(w * 0.4, h * 0.82, 50, 2.5));
                world.addObstacle(new Spinner(w * 0.6, h * 0.82, 50, -2.5));

                // ===== ë ˆì´ì–´ 8 (84% ~ 95%) - ìµœí•˜ë‹¨ =====
                world.addObstacle(new Bumper(w * 0.2, h * 0.86, 24));
                world.addObstacle(new Bumper(w * 0.35, h * 0.88, 22));
                world.addObstacle(new Bumper(w * 0.5, h * 0.85, 26));
                world.addObstacle(new Bumper(w * 0.65, h * 0.88, 22));
                world.addObstacle(new Bumper(w * 0.8, h * 0.86, 24));
                world.addObstacle(new Booster(w * 0.25, h * 0.92, -Math.PI / 2, 550));
                world.addObstacle(new Booster(w * 0.5, h * 0.94, -Math.PI / 2, 650));
                world.addObstacle(new Booster(w * 0.75, h * 0.92, -Math.PI / 2, 550));
                world.addObstacle(new Spinner(w * 0.15, h * 0.92, 40, 3));
                world.addObstacle(new Spinner(w * 0.85, h * 0.92, 40, -3));
            }
        };

        // ===== Game Controller =====
        class MarbleRoulette {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.world = null;
                this.participants = [];
                this.mapType = 'chaos';
                this.isRunning = false;
                this.animationId = null;
                this.lastTime = 0;
                this.gameStartTime = 0;

                this.colors = [
                    '#ff6b6b', '#feca57', '#48dbfb', '#ff9ff3', '#54a0ff',
                    '#5f27cd', '#00d2d3', '#ff6b9d', '#c8d6e5', '#10ac84',
                    '#ee5a24', '#0abde3', '#f368e0', '#576574', '#01a3a4',
                    '#9b59b6', '#3498db', '#e74c3c', '#2ecc71', '#f39c12'
                ];

                this.resize();
                window.addEventListener('resize', () => this.resize());
            }

            resize() {
                const wrapper = this.canvas.parentElement;
                this.canvas.width = wrapper.clientWidth;
                this.canvas.height = wrapper.clientHeight;
                
                if (!this.isRunning) {
                    this.setupWorld();
                    this.draw();
                }
            }

            setParticipants(participants) {
                this.participants = participants;
                if (!this.isRunning) {
                    this.setupWorld();
                    this.draw();
                }
            }

            setMap(mapType) {
                this.mapType = mapType;
                // ì‹¤í–‰ ì¤‘ì´ë©´ ë¦¬ì…‹
                if (this.isRunning) {
                    this.stop();
                    document.getElementById('liveIndicator').style.display = 'none';
                    document.getElementById('rankingList').innerHTML = '<div class="ranking-placeholder">ê²Œì„ì„ ì‹œì‘í•˜ë©´ ìˆœìœ„ê°€ í‘œì‹œë©ë‹ˆë‹¤</div>';
                }
                this.setupWorld();
                this.draw();
            }

            shuffle() {
                for (let i = this.participants.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.participants[i], this.participants[j]] = [this.participants[j], this.participants[i]];
                }
                this.setupWorld();
                this.draw();
            }

            setupWorld() {
                const w = this.canvas.width;
                const viewH = this.canvas.height;

                this.world = new PhysicsWorld(w, viewH);

                // Apply selected map (world.heightëŠ” viewH * 3)
                if (MapGenerators[this.mapType]) {
                    MapGenerators[this.mapType](this.world, w, this.world.height);
                }

                // Create balls
                const ballRadius = Math.max(10, Math.min(18, 250 / Math.max(1, this.participants.length)));
                const startArea = w * 0.6;
                const startX = (w - startArea) / 2;

                this.participants.forEach((name, i) => {
                    const x = startX + Math.random() * startArea;
                    const y = -20 - Math.random() * 80 - i * 8;
                    const color = this.colors[i % this.colors.length];
                    this.world.addBall(new Ball(x, y, ballRadius, color, name));
                });
            }

            start() {
                if (this.participants.length === 0) return;
                
                this.isRunning = true;
                this.setupWorld();
                this.gameStartTime = performance.now();
                this.lastTime = performance.now();
                this.animate();

                document.getElementById('rankingList').innerHTML = '<div class="ranking-placeholder">ì²« ë²ˆì§¸ ë„ì°©ìë¥¼ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...</div>';
                document.getElementById('liveIndicator').style.display = 'flex';
            }

            stop() {
                this.isRunning = false;
                if (this.animationId) cancelAnimationFrame(this.animationId);
            }

            reset() {
                this.stop();
                this.setupWorld();
                this.draw();
                document.getElementById('rankingList').innerHTML = '<div class="ranking-placeholder">ê²Œì„ì„ ì‹œì‘í•˜ë©´ ìˆœìœ„ê°€ í‘œì‹œë©ë‹ˆë‹¤</div>';
                document.getElementById('liveIndicator').style.display = 'none';
                document.getElementById('winnerOverlay').classList.remove('show');
            }

            animate() {
                if (!this.isRunning) return;

                const now = performance.now();
                const dt = Math.min((now - this.lastTime) / 1000, 0.016);
                this.lastTime = now;

                this.world.update(dt);
                this.updateRankings();
                this.draw();

                if (this.world.isFinished()) {
                    this.isRunning = false;
                    this.showWinner();
                    return;
                }

                this.animationId = requestAnimationFrame(() => this.animate());
            }

            updateRankings() {
                const list = document.getElementById('rankingList');
                
                // ì•„ì§ ì•„ë¬´ë„ ë„ì°© ì•ˆ í–ˆìœ¼ë©´
                if (this.world.rankings.length === 0) {
                    const remaining = this.world.balls.filter(b => !b.finished).length;
                    list.innerHTML = `<div class="ranking-placeholder">â³ ${remaining}ëª… ë ˆì´ì‹± ì¤‘...</div>`;
                    return;
                }
                
                // ë„ì°©í•œ ê³µì´ ìˆìœ¼ë©´ ìˆœìœ„ í‘œì‹œ
                let html = '';
                const medals = ['ğŸ¥‡', 'ğŸ¥ˆ', 'ğŸ¥‰'];
                const firstTime = this.world.rankings[0]?.finishTime || 0;
                const firstTimeInSec = firstTime ? (firstTime - this.gameStartTime) / 1000 : 0;

                this.world.rankings.forEach((ball, i) => {
                    const rankClass = i < 3 ? `rank-${i + 1}` : '';
                    const ballTimeInSec = (ball.finishTime - this.gameStartTime) / 1000;
                    let timeDisplay;
                    if (i === 0) {
                        timeDisplay = `${ballTimeInSec.toFixed(2)}s`;
                    } else {
                        const diff = ballTimeInSec - firstTimeInSec;
                        timeDisplay = `+${diff.toFixed(2)}s`;
                    }
                    
                    html += `
                        <div class="ranking-item ${rankClass}">
                            <div class="ranking-position">${i + 1}</div>
                            <div class="ranking-color" style="background: ${ball.color};"></div>
                            <div class="ranking-name">${ball.name}</div>
                            ${i < 3 ? `<span class="ranking-medal">${medals[i]}</span>` : ''}
                            <span class="ranking-time">${timeDisplay}</span>
                        </div>
                    `;
                });

                // ì•„ì§ ë„ì°© ì•ˆ í•œ ê³µë“¤ ìˆ˜ í‘œì‹œ
                const remaining = this.world.balls.filter(b => !b.finished).length;
                if (remaining > 0) {
                    html += `<div class="ranking-remaining">â³ ${remaining}ëª… ì§„í–‰ ì¤‘...</div>`;
                }
                
                list.innerHTML = html;
            }

            showWinner() {
                const rankings = this.world.rankings;
                const winner = rankings[0];

                document.getElementById('winnerLabel').textContent = 'ğŸ† 1ë“±!';
                document.getElementById('winnerName').textContent = winner.name;
                
                // ì „ì²´ ìˆœìœ„ í‘œì‹œ
                const finalList = document.getElementById('finalRankingList');
                finalList.innerHTML = '';
                
                const medals = ['ğŸ¥‡', 'ğŸ¥ˆ', 'ğŸ¥‰'];
                const firstTime = rankings[0]?.finishTime || 0;
                const firstTimeInSec = (firstTime - this.gameStartTime) / 1000;

                rankings.forEach((ball, i) => {
                    const item = document.createElement('div');
                    const isLast = i === rankings.length - 1;
                    let rankClass = '';
                    if (i < 3) rankClass = `rank-${i + 1}`;
                    else if (isLast && rankings.length > 3) rankClass = 'rank-last';
                    
                    item.className = `final-ranking-item ${rankClass}`;
                    item.style.animationDelay = `${i * 0.08}s`;
                    
                    // 1ë“±: ê¸°ë¡ ì‹œê°„, ë‚˜ë¨¸ì§€: ê¸°ë¡ì‹œê°„ (+diff)
                    const ballTimeInSec = (ball.finishTime - this.gameStartTime) / 1000;
                    let timeDisplay;
                    if (i === 0) {
                        timeDisplay = `${ballTimeInSec.toFixed(2)}s`;
                    } else {
                        const diff = ballTimeInSec - firstTimeInSec;
                        timeDisplay = `${ballTimeInSec.toFixed(2)}s (+${diff.toFixed(2)}s)`;
                    }
                    
                    let medal = '';
                    if (i < 3) medal = medals[i];
                    else if (isLast && rankings.length > 3) medal = 'ğŸ’€';
                    
                    item.innerHTML = `
                        <div class="final-position">${i + 1}</div>
                        <div class="final-color" style="background: ${ball.color}"></div>
                        <div class="final-name">${ball.name}</div>
                        <span class="final-time">${timeDisplay}</span>
                        <span class="final-medal">${medal}</span>
                    `;
                    finalList.appendChild(item);
                });

                document.getElementById('winnerOverlay').classList.add('show');
                document.getElementById('liveIndicator').style.display = 'none';

                this.createConfetti();
            }

            createConfetti() {
                const container = document.getElementById('confettiContainer');
                container.innerHTML = '';

                const colors = ['#ff6b6b', '#ffd93d', '#6bcb77', '#4d96ff', '#ff6b9d', '#a855f7'];
                
                for (let i = 0; i < 100; i++) {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti';
                    confetti.style.left = Math.random() * 100 + '%';
                    confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
                    confetti.style.animationDelay = Math.random() * 2 + 's';
                    confetti.style.animationDuration = (2 + Math.random() * 2) + 's';
                    if (Math.random() > 0.5) confetti.style.borderRadius = '50%';
                    container.appendChild(confetti);
                }
            }

            draw() {
                const ctx = this.ctx;
                const w = this.canvas.width;
                const h = this.canvas.height;

                // Clear
                ctx.fillStyle = 'rgba(10, 10, 18, 0.97)';
                ctx.fillRect(0, 0, w, h);

                if (!this.world) return;

                // ì¹´ë©”ë¼ ì˜¤í”„ì…‹ ì ìš©
                const camY = this.world.cameraY || 0;
                ctx.save();
                ctx.translate(0, -camY);

                // Draw finish line (ì›”ë“œ ì¢Œí‘œ)
                const finishLineY = this.world.finishLine;
                const gradient = ctx.createLinearGradient(0, finishLineY, 0, finishLineY + 100);
                gradient.addColorStop(0, 'rgba(255, 215, 0, 0.25)');
                gradient.addColorStop(1, 'rgba(255, 215, 0, 0.08)');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, finishLineY, w, 100);

                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 2;
                ctx.setLineDash([8, 8]);
                ctx.beginPath();
                ctx.moveTo(0, finishLineY);
                ctx.lineTo(w, finishLineY);
                ctx.stroke();
                ctx.setLineDash([]);

                ctx.font = 'bold 12px "Noto Sans KR"';
                ctx.fillStyle = '#ffd700';
                ctx.textAlign = 'right';
                ctx.fillText('ğŸ† GOAL', w - 15, finishLineY - 8);

                // Draw obstacles
                for (const obs of this.world.obstacles) {
                    this.drawObstacle(obs);
                }

                // Draw balls
                for (const ball of this.world.balls) {
                    this.drawBall(ball);
                }

                ctx.restore();
                
                // UI ì˜¤ë²„ë ˆì´ (ì¹´ë©”ë¼ ì˜í–¥ ì•ˆ ë°›ìŒ)
                this.drawProgressBar();
            }
            
            drawProgressBar() {
                if (!this.world || !this.isRunning) return;
                
                const ctx = this.ctx;
                const w = this.canvas.width;
                
                // ì§„í–‰ë„ ë°” (ìƒë‹¨)
                const leader = this.world.getLeadingBall();
                if (leader) {
                    const progress = Math.min(leader.pos.y / this.world.finishLine, 1);
                    
                    // ë°°ê²½
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    ctx.fillRect(10, 10, w - 20, 8);
                    
                    // ì§„í–‰ë„
                    const gradient = ctx.createLinearGradient(10, 0, w - 10, 0);
                    gradient.addColorStop(0, '#ffd700');
                    gradient.addColorStop(1, '#ff6b6b');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(10, 10, (w - 20) * progress, 8);
                    
                    // í…Œë‘ë¦¬
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(10, 10, w - 20, 8);
                    
                    // í¼ì„¼íŠ¸ í‘œì‹œ
                    ctx.font = 'bold 10px "Noto Sans KR"';
                    ctx.fillStyle = '#fff';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${Math.floor(progress * 100)}%`, w / 2, 32);
                }
            }

            drawObstacle(obs) {
                const ctx = this.ctx;
                const time = this.world ? this.world.time : 0;

                if (obs.type === 'peg') {
                    ctx.fillStyle = obs.color;
                    ctx.beginPath();
                    ctx.arc(obs.x, obs.y, obs.radius, 0, Math.PI * 2);
                    ctx.fill();
                } else if (obs.type === 'bumper') {
                    const scale = 1 + Math.max(0, 0.3 - (time - obs.hitTime)) * 0.5;
                    const glow = ctx.createRadialGradient(obs.x, obs.y, 0, obs.x, obs.y, obs.radius * scale * 1.5);
                    glow.addColorStop(0, obs.color);
                    glow.addColorStop(0.6, obs.color + '80');
                    glow.addColorStop(1, 'transparent');
                    ctx.fillStyle = glow;
                    ctx.beginPath();
                    ctx.arc(obs.x, obs.y, obs.radius * scale * 1.5, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = obs.color;
                    ctx.beginPath();
                    ctx.arc(obs.x, obs.y, obs.radius * scale, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(obs.x - obs.radius * 0.3, obs.y - obs.radius * 0.3, obs.radius * 0.25, 0, Math.PI * 2);
                    ctx.fill();
                } else if (obs.type === 'spinner') {
                    const ep = obs.getEndpoints();
                    ctx.strokeStyle = obs.color;
                    ctx.lineWidth = 8;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(ep.x1, ep.y1);
                    ctx.lineTo(ep.x2, ep.y2);
                    ctx.stroke();

                    // Center pivot
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(obs.x, obs.y, 6, 0, Math.PI * 2);
                    ctx.fill();
                } else if (obs.type === 'portal') {
                    // Draw both portal ends
                    for (const [px, py] of [[obs.x1, obs.y1], [obs.x2, obs.y2]]) {
                        const pulse = 1 + Math.sin(time * 4) * 0.1;
                        const glow = ctx.createRadialGradient(px, py, 0, px, py, obs.radius * pulse * 1.5);
                        glow.addColorStop(0, obs.color);
                        glow.addColorStop(0.5, obs.color + '60');
                        glow.addColorStop(1, 'transparent');
                        ctx.fillStyle = glow;
                        ctx.beginPath();
                        ctx.arc(px, py, obs.radius * pulse * 1.5, 0, Math.PI * 2);
                        ctx.fill();

                        ctx.strokeStyle = obs.color;
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(px, py, obs.radius * pulse, 0, Math.PI * 2);
                        ctx.stroke();

                        // Inner swirl
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        for (let a = 0; a < Math.PI * 2; a += 0.1) {
                            const r = obs.radius * 0.6 * (1 - a / (Math.PI * 2));
                            const x = px + Math.cos(a + time * 3) * r;
                            const y = py + Math.sin(a + time * 3) * r;
                            if (a === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        ctx.stroke();
                    }
                } else if (obs.type === 'booster') {
                    const scale = 1 + Math.max(0, 0.2 - (time - obs.hitTime)) * 0.4;
                    
                    ctx.fillStyle = obs.color;
                    ctx.beginPath();
                    ctx.arc(obs.x, obs.y, obs.radius * scale, 0, Math.PI * 2);
                    ctx.fill();

                    // Arrow
                    ctx.save();
                    ctx.translate(obs.x, obs.y);
                    ctx.rotate(obs.angle);
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.moveTo(obs.radius * 0.6, 0);
                    ctx.lineTo(-obs.radius * 0.3, -obs.radius * 0.4);
                    ctx.lineTo(-obs.radius * 0.3, obs.radius * 0.4);
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                } else if (obs.type === 'wall') {
                    ctx.strokeStyle = obs.color;
                    ctx.lineWidth = obs.thickness;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(obs.x1, obs.y1);
                    ctx.lineTo(obs.x2, obs.y2);
                    ctx.stroke();
                } else if (obs.type === 'triangle') {
                    const verts = obs.getVertices();
                    ctx.fillStyle = obs.color;
                    ctx.beginPath();
                    ctx.moveTo(verts[0].x, verts[0].y);
                    for (let i = 1; i < verts.length; i++) {
                        ctx.lineTo(verts[i].x, verts[i].y);
                    }
                    ctx.closePath();
                    ctx.fill();
                }
            }

            drawBall(ball) {
                const ctx = this.ctx;

                // Trail
                if (ball.trail.length > 1) {
                    ctx.strokeStyle = ball.color + '40';
                    ctx.lineWidth = ball.radius * 0.8;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.beginPath();
                    ctx.moveTo(ball.trail[0].x, ball.trail[0].y);
                    for (let i = 1; i < ball.trail.length; i++) {
                        ctx.lineTo(ball.trail[i].x, ball.trail[i].y);
                    }
                    ctx.stroke();
                }

                // Glow
                const glowGradient = ctx.createRadialGradient(
                    ball.pos.x, ball.pos.y, 0,
                    ball.pos.x, ball.pos.y, ball.radius * 2
                );
                glowGradient.addColorStop(0, ball.color + '60');
                glowGradient.addColorStop(1, 'transparent');
                ctx.fillStyle = glowGradient;
                ctx.beginPath();
                ctx.arc(ball.pos.x, ball.pos.y, ball.radius * 2, 0, Math.PI * 2);
                ctx.fill();

                // Ball body
                const ballGradient = ctx.createRadialGradient(
                    ball.pos.x - ball.radius * 0.3, ball.pos.y - ball.radius * 0.3, 0,
                    ball.pos.x, ball.pos.y, ball.radius
                );
                ballGradient.addColorStop(0, '#ffffff');
                ballGradient.addColorStop(0.3, ball.color);
                ballGradient.addColorStop(1, this.darkenColor(ball.color, 40));
                
                ctx.fillStyle = ballGradient;
                ctx.beginPath();
                ctx.arc(ball.pos.x, ball.pos.y, ball.radius, 0, Math.PI * 2);
                ctx.fill();

                // Name
                ctx.font = `bold ${Math.max(8, ball.radius * 0.65)}px "Noto Sans KR"`;
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                const shortName = ball.name.length > 4 ? ball.name.slice(0, 3) + '..' : ball.name;
                ctx.fillText(shortName, ball.pos.x, ball.pos.y);
            }

            darkenColor(color, percent) {
                const num = parseInt(color.replace('#', ''), 16);
                const amt = Math.round(2.55 * percent);
                const R = Math.max(0, (num >> 16) - amt);
                const G = Math.max(0, ((num >> 8) & 0x00FF) - amt);
                const B = Math.max(0, (num & 0x0000FF) - amt);
                return '#' + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
            }
        }

        // ===== Main =====
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('gameCanvas');
            const game = new MarbleRoulette(canvas);

            const participantsInput = document.getElementById('participants');
            const preview = document.getElementById('participantsPreview');
            const mapSelect = document.getElementById('mapSelect');
            const shuffleBtn = document.getElementById('shuffleBtn');
            const startBtn = document.getElementById('startBtn');
            const resetBtn = document.getElementById('resetBtn');
            const closeWinnerBtn = document.getElementById('closeWinnerBtn');
            const helpBtn = document.getElementById('helpBtn');
            const helpModal = document.getElementById('helpModal');
            const closeHelpBtn = document.getElementById('closeHelpBtn');

            function parseParticipants(text) {
                const lines = text.split(/[\n,]+/).map(s => s.trim()).filter(Boolean);
                const participants = [];

                for (const line of lines) {
                    const match = line.match(/^(.+?)\*(\d+)$/);
                    if (match) {
                        const name = match[1].trim();
                        const count = parseInt(match[2], 10);
                        for (let i = 0; i < count; i++) participants.push(name);
                    } else {
                        participants.push(line);
                    }
                }
                return participants;
            }

            function updatePreview() {
                const participants = parseParticipants(participantsInput.value);
                
                if (participants.length === 0) {
                    preview.innerHTML = '<span style="color: #666;">ì°¸ì—¬ìë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”</span>';
                    return;
                }

                const colors = game.colors;
                preview.innerHTML = participants.map((name, i) => `
                    <span class="participant-tag">
                        <span class="participant-color" style="background: ${colors[i % colors.length]}"></span>
                        ${name}
                    </span>
                `).join('');

                game.setParticipants(participants);
            }

            participantsInput.addEventListener('input', updatePreview);

            // ë§µ ì„ íƒ ë“œë¡­ë‹¤ìš´
            mapSelect.addEventListener('change', () => {
                game.setMap(mapSelect.value);
            });

            // ë„ì›€ë§ ëª¨ë‹¬
            helpBtn.addEventListener('click', () => {
                helpModal.classList.add('show');
            });

            closeHelpBtn.addEventListener('click', () => {
                helpModal.classList.remove('show');
            });

            helpModal.addEventListener('click', (e) => {
                if (e.target === helpModal) {
                    helpModal.classList.remove('show');
                }
            });

            shuffleBtn.addEventListener('click', () => {
                if (game.participants.length > 0) {
                    game.shuffle();
                    updatePreview();
                }
            });

            startBtn.addEventListener('click', () => {
                const participants = parseParticipants(participantsInput.value);
                if (participants.length < 2) {
                    alert('ìµœì†Œ 2ëª… ì´ìƒì˜ ì°¸ì—¬ìê°€ í•„ìš”í•©ë‹ˆë‹¤!');
                    return;
                }
                game.setParticipants(participants);
                game.start();
            });

            resetBtn.addEventListener('click', () => game.reset());
            closeWinnerBtn.addEventListener('click', () => {
                document.getElementById('winnerOverlay').classList.remove('show');
            });

            // Initial setup
            game.setupWorld();
            game.draw();
            document.getElementById('rankingList').innerHTML = '<div class="ranking-placeholder">ê²Œì„ì„ ì‹œì‘í•˜ë©´ ìˆœìœ„ê°€ í‘œì‹œë©ë‹ˆë‹¤</div>';
        });
    </script>
</body>
</html>
